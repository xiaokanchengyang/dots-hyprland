import{a as l}from"./24353KEQ.js";function b(a,e){let t=new Set;for(let i of e)a.has(i)&&t.add(i);return t}function m(a,e){let t=new Set(a);for(let i of e)t.add(i);return t}function c(a,e){let t=new Set(a);for(let i of e)t.delete(i);return t}function h(a){return Array.from(a).map(e=>`"${e}"`).join(", ")}var p=class extends l{get inputKeys(){return this.inputVariables}get outputKeys(){return this.outputVariables}constructor(e){var t,i;if(super(e),Object.defineProperty(this,"chains",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnAll",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.chains=e.chains,this.inputVariables=e.inputVariables,this.outputVariables=(t=e.outputVariables)!=null?t:[],this.outputVariables.length>0&&e.returnAll)throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.");this.returnAll=(i=e.returnAll)!=null?i:!1,this._validateChains()}_validateChains(){var r,u;if(this.chains.length===0)throw new Error("Sequential chain must have at least one chain.");let e=(u=(r=this.memory)==null?void 0:r.memoryKeys)!=null?u:[],t=new Set(this.inputKeys),i=new Set(e),n=b(t,i);if(n.size>0)throw new Error(`The following keys: ${h(n)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);let s=m(t,i);for(let o of this.chains){let y=c(new Set(o.inputKeys),s);if(y.size>0)throw new Error(`Missing variables for chain "${o._chainType()}": ${h(y)}. Only got the following variables: ${h(s)}.`);let d=new Set(o.outputKeys),w=b(s,d);if(w.size>0)throw new Error(`The following output variables for chain "${o._chainType()}" are overlapping: ${h(w)}. This can lead to unexpected behaviour.`);for(let v of d)s.add(v)}if(this.outputVariables.length===0)if(this.returnAll){let o=c(s,t);this.outputVariables=Array.from(o)}else this.outputVariables=this.chains[this.chains.length-1].outputKeys;else{let o=c(new Set(this.outputVariables),new Set(s));if(o.size>0)throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${h(o)}.`)}}async _call(e,t){let i=e,n={};for(let r of this.chains){i=await r.call(i,t==null?void 0:t.getChild());for(let u of Object.keys(i))n[u]=i[u]}let s={};for(let r of this.outputVariables)s[r]=n[r];return s}_chainType(){return"sequential_chain"}static async deserialize(e){let t=[],i=e.input_variables,n=e.output_variables,s=e.chains;for(let r of s){let u=await l.deserialize(r);t.push(u)}return new p({chains:t,inputVariables:i,outputVariables:n})}serialize(){let e=[];for(let t of this.chains)e.push(t.serialize());return{_type:this._chainType(),input_variables:this.inputVariables,output_variables:this.outputVariables,chains:e}}},f=class extends l{get inputKeys(){return[this.inputKey]}get outputKeys(){return[this.outputKey]}constructor(e){var t,i;super(e.memory,e.verbose,(t=e.callbacks)!=null?t:e.callbackManager),Object.defineProperty(this,"chains",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"input"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"output"}),Object.defineProperty(this,"trimOutputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.chains=e.chains,this.trimOutputs=(i=e.trimOutputs)!=null?i:!1,this._validateChains()}_validateChains(){for(let e of this.chains){if(e.inputKeys.length!==1)throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${e.inputKeys.length} for ${e._chainType()}.`);if(e.outputKeys.length!==1)throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${e.outputKeys.length} for ${e._chainType()}.`)}}async _call(e,t){let i=e[this.inputKey];for(let n of this.chains)i=await n.run(i,t==null?void 0:t.getChild()),this.trimOutputs&&(i=i.trim()),await(t==null?void 0:t.handleText(i));return{[this.outputKey]:i}}_chainType(){return"simple_sequential_chain"}static async deserialize(e){let t=[],i=e.chains;for(let n of i){let s=await l.deserialize(n);t.push(s)}return new f({chains:t})}serialize(){let e=[];for(let t of this.chains)e.push(t.serialize());return{_type:this._chainType(),chains:e}}};export{p as a,f as b};
