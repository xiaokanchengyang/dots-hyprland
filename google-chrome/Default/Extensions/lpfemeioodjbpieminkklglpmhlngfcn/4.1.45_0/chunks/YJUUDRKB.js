import{S as xr}from"./EUSDRET5.js";import{a as Pr}from"./BXPPDSGN.js";import{f as Zn}from"./3PS7M655.js";var H=Zn(Pr()),mo=Zn(xr());function Fr(e){let t=new Error(e);if(t.stack===void 0)try{throw t}catch(n){}return t}var zr=Fr,U=zr;function Wr(e){return!!e&&typeof e.then=="function"}var K=Wr;function Gr(e,t){if(e!=null)return e;throw U(t!=null?t:"Got unexpected null or undefined")}var Y=Gr;function I(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Fe=class{getValue(){throw U("BaseLoadable")}toPromise(){throw U("BaseLoadable")}valueMaybe(){throw U("BaseLoadable")}valueOrThrow(){throw U(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw U("BaseLoadable")}promiseOrThrow(){throw U(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw U("BaseLoadable")}errorOrThrow(){throw U(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw U("BaseLoadable")}},fn=class extends Fe{constructor(t){super(),I(this,"state","hasValue"),I(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{let n=t(this.contents);return K(n)?Ve(n):ze(n)?n:ut(n)}catch(n){return K(n)?Ve(n.next(()=>this.map(t))):kt(n)}}},hn=class extends Fe{constructor(t){super(),I(this,"state","hasError"),I(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}},Et=class extends Fe{constructor(t){super(),I(this,"state","loading"),I(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ve(this.contents.then(n=>{let o=t(n);if(ze(o)){let r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}};function ut(e){return Object.freeze(new fn(e))}function kt(e){return Object.freeze(new hn(e))}function Ve(e){return Object.freeze(new Et(e))}function yo(){return Object.freeze(new Et(new Promise(()=>{})))}function Kr(e){return e.every(t=>t.state==="hasValue")?ut(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?kt(Y(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ve(Promise.all(e.map(t=>t.contents)))}function go(e){let n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>ze(r)?r:K(r)?Ve(r):ut(r)),o=Kr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,l)=>({...a,[i]:r[l]}),{}))}function ze(e){return e instanceof Fe}var Hr={of:e=>K(e)?Ve(e):ze(e)?e:ut(e),error:e=>kt(e),loading:()=>yo(),all:go,isLoadable:ze},$e={loadableWithValue:ut,loadableWithError:kt,loadableWithPromise:Ve,loadableLoading:yo,loadableAll:go,isLoadable:ze,RecoilLoadable:Hr},qr=$e.loadableWithValue,jr=$e.loadableWithError,Zr=$e.loadableWithPromise,Yr=$e.loadableLoading,Xr=$e.loadableAll,Jr=$e.isLoadable,Qr=$e.RecoilLoadable,dt=Object.freeze({__proto__:null,loadableWithValue:qr,loadableWithError:jr,loadableWithPromise:Zr,loadableLoading:Yr,loadableAll:Xr,isLoadable:Jr,RecoilLoadable:Qr}),_n={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function ea(e,t){var n,o;let r=(n=process.env[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw U(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function ta(e,t){var n;let o=(n=process.env[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function na(){var e;typeof process!="undefined"&&((e=process)===null||e===void 0?void 0:e.env)!=null&&(ea("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{_n.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),ta("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{_n.RECOIL_GKS_ENABLED.add(n)})}))}na();var qe=_n;function Bt(e){return qe.RECOIL_GKS_ENABLED.has(e)}Bt.setPass=e=>{qe.RECOIL_GKS_ENABLED.add(e)};Bt.setFail=e=>{qe.RECOIL_GKS_ENABLED.delete(e)};Bt.clear=()=>{qe.RECOIL_GKS_ENABLED.clear()};var G=Bt;function oa(e,t,{error:n}={}){return null}var ra=oa,se=ra,on,rn,an,aa=(on=H.default.createMutableSource)!==null&&on!==void 0?on:H.default.unstable_createMutableSource,bo=(rn=H.default.useMutableSource)!==null&&rn!==void 0?rn:H.default.unstable_useMutableSource,Ln=(an=H.default.useSyncExternalStore)!==null&&an!==void 0?an:H.default.unstable_useSyncExternalStore,Yn=!1;function ia(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=H.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Ln&&!r&&!Yn&&(Yn=!0,se("A React renderer without React 18+ API support is being used with React 18+.")),r}function sa(){return G("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:G("recoil_sync_external_store")&&Ln!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:G("recoil_mutable_source")&&bo!=null&&typeof window!="undefined"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?G("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:G("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function ca(){return!1}var je={createMutableSource:aa,useMutableSource:bo,useSyncExternalStore:Ln,currentRendererSupportsUseSyncExternalStore:ia,reactMode:sa,isFastRefreshEnabled:ca},st=class{constructor(t){I(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}},Nt=class extends st{},wt=class extends st{};function la(e){return e instanceof Nt||e instanceof wt}var Pt={AbstractRecoilValue:st,RecoilState:Nt,RecoilValueReadOnly:wt,isRecoilValue:la},ua=Pt.AbstractRecoilValue,da=Pt.RecoilState,fa=Pt.RecoilValueReadOnly,ha=Pt.isRecoilValue,Le=Object.freeze({__proto__:null,AbstractRecoilValue:ua,RecoilState:da,RecoilValueReadOnly:fa,isRecoilValue:ha});function _a(e,...t){}var pa=_a,Cn=pa;function va(e,t){return function*(){let n=0;for(let o of e)yield t(o,n++)}()}var xt=va,{isFastRefreshEnabled:Ed}=je,At=class{},Ra=new At,Ce=new Map,$n=new Map;function Sa(e){return xt(e,t=>Y($n.get(t)))}function ma(e){if(Ce.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`}}function ya(e){qe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ma(e.key),Ce.set(e.key,e);let t=e.set==null?new Le.RecoilValueReadOnly(e.key):new Le.RecoilState(e.key);return $n.set(e.key,t),t}var Vt=class extends Error{};function ga(e){let t=Ce.get(e);if(t==null)throw new Vt(`Missing definition for RecoilValue: "${e}""`);return t}function ba(e){return Ce.get(e)}var Lt=new Map;function Ta(e){var t;if(!G("recoil_memory_managament_2020"))return;let n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=To(e))===null||o===void 0||o(),Lt.delete(e)}}function Ea(e,t){G("recoil_memory_managament_2020")&&(t===void 0?Lt.delete(e):Lt.set(e,t))}function To(e){return Lt.get(e)}var de={nodes:Ce,recoilValues:$n,registerNode:ya,getNode:ga,getNodeMaybe:ba,deleteNodeConfigIfPossible:Ta,setConfigDeletionHandler:Ea,getConfigDeletionHandler:To,recoilValuesForKeys:Sa,NodeMissingError:Vt,DefaultValue:At,DEFAULT_VALUE:Ra};function Na(e,t){t()}var wa={enqueueExecution:Na};function Aa(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Va=Aa(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,l=r/4,u={},f=function(s){return function(){return s}},_=n.hash=function(c){var s=typeof c=="undefined"?"undefined":t(c);if(s==="number")return c;s!=="string"&&(c+="");for(var h=0,S=0,m=c.length;S<m;++S){var g=c.charCodeAt(S);h=(h<<5)-h+g|0}return h},v=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},C=function(s,h){return h>>>s&a},L=function(s){return 1<<s},y=function(s,h){return v(s&h-1)},N=function(s,h,S,m){var g=m;if(!s){var V=m.length;g=new Array(V);for(var w=0;w<V;++w)g[w]=m[w]}return g[h]=S,g},X=function(s,h,S){var m=S.length-1,g=0,V=0,w=S;if(s)g=V=h;else for(w=new Array(m);g<h;)w[V++]=S[g++];for(++g;g<=m;)w[V++]=S[g++];return s&&(w.length=m),w},ne=function(s,h,S,m){var g=m.length;if(s){for(var V=g;V>=h;)m[V--]=m[V];return m[h]=S,m}for(var w=0,A=0,D=new Array(g+1);w<h;)D[A++]=m[w++];for(D[h]=S;w<g;)D[++A]=m[w++];return D},E=1,B=2,J=3,z=4,q={__hamt_isEmpty:!0},Q=function(s){return s===q||s&&s.__hamt_isEmpty},ce=function(s,h,S,m){return{type:E,edit:s,hash:h,key:S,value:m,_modify:Me}},ye=function(s,h,S){return{type:B,edit:s,hash:h,children:S,_modify:Oe}},F=function(s,h,S){return{type:J,edit:s,mask:h,children:S,_modify:P}},ae=function(s,h,S){return{type:z,edit:s,size:h,children:S,_modify:x}},we=function(s){return s===q||s.type===E||s.type===B},re=function(s,h,S,m,g){for(var V=[],w=m,A=0,D=0;w;++D)w&1&&(V[D]=g[A++]),w>>>=1;return V[h]=S,ae(s,A+1,V)},fe=function(s,h,S,m){for(var g=new Array(h-1),V=0,w=0,A=0,D=m.length;A<D;++A)if(A!==S){var Z=m[A];Z&&!Q(Z)&&(g[V++]=Z,w|=1<<A)}return F(s,w,g)},Ue=function c(s,h,S,m,g,V){if(S===g)return ye(s,S,[V,m]);var w=C(h,S),A=C(h,g);return F(s,L(w)|L(A),w===A?[c(s,h+o,S,m,g,V)]:w<A?[m,V]:[V,m])},De=function(s,h,S,m,g,V,w,A){for(var D=g.length,Z=0;Z<D;++Z){var le=g[Z];if(S(w,le.key)){var oe=le.value,pe=V(oe);return pe===oe?g:pe===u?(--A.value,X(s,Z,g)):N(s,Z,ce(h,m,w,pe),g)}}var ve=V();return ve===u?g:(++A.value,N(s,D,ce(h,m,w,ve),g))},ge=function(s,h){return s===h.edit},Me=function(s,h,S,m,g,V,w){if(h(V,this.key)){var A=m(this.value);return A===this.value?this:A===u?(--w.value,q):ge(s,this)?(this.value=A,this):ce(s,g,V,A)}var D=m();return D===u?this:(++w.value,Ue(s,S,this.hash,this,g,ce(s,g,V,D)))},Oe=function(s,h,S,m,g,V,w){if(g===this.hash){var A=ge(s,this),D=De(A,s,h,this.hash,this.children,m,V,w);return D===this.children?this:D.length>1?ye(s,this.hash,D):D[0]}var Z=m();return Z===u?this:(++w.value,Ue(s,S,this.hash,this,g,ce(s,g,V,Z)))},P=function(s,h,S,m,g,V,w){var A=this.mask,D=this.children,Z=C(S,g),le=L(Z),oe=y(A,le),pe=A&le,ve=pe?D[oe]:q,Be=ve._modify(s,h,S+o,m,g,V,w);if(ve===Be)return this;var Rt=ge(s,this),Ye=A,Xe=void 0;if(pe&&Q(Be)){if(Ye&=~le,!Ye)return q;if(D.length<=2&&we(D[oe^1]))return D[oe^1];Xe=X(Rt,oe,D)}else if(!pe&&!Q(Be)){if(D.length>=i)return re(s,Z,Be,A,D);Ye|=le,Xe=ne(Rt,oe,Be,D)}else Xe=N(Rt,oe,Be,D);return Rt?(this.mask=Ye,this.children=Xe,this):F(s,Ye,Xe)},x=function(s,h,S,m,g,V,w){var A=this.size,D=this.children,Z=C(S,g),le=D[Z],oe=(le||q)._modify(s,h,S+o,m,g,V,w);if(le===oe)return this;var pe=ge(s,this),ve=void 0;if(Q(le)&&!Q(oe))++A,ve=N(pe,Z,oe,D);else if(!Q(le)&&Q(oe)){if(--A,A<=l)return fe(s,A,Z,D);ve=N(pe,Z,q,D)}else ve=N(pe,Z,oe,D);return pe?(this.size=A,this.children=ve,this):ae(s,A,ve)};q._modify=function(c,s,h,S,m,g,V){var w=S();return w===u?q:(++V.value,ce(c,m,g,w))};function d(c,s,h,S,m){this._editable=c,this._edit=s,this._config=h,this._root=S,this._size=m}d.prototype.setTree=function(c,s){return this._editable?(this._root=c,this._size=s,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,s)};var p=n.tryGetHash=function(c,s,h,S){for(var m=S._root,g=0,V=S._config.keyEq;;)switch(m.type){case E:return V(h,m.key)?m.value:c;case B:{if(s===m.hash)for(var w=m.children,A=0,D=w.length;A<D;++A){var Z=w[A];if(V(h,Z.key))return Z.value}return c}case J:{var le=C(g,s),oe=L(le);if(m.mask&oe){m=m.children[y(m.mask,oe)],g+=o;break}return c}case z:{if(m=m.children[C(g,s)],m){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,s,h){return p(c,s,h,this)};var R=n.tryGet=function(c,s,h){return p(c,h._config.hash(s),s,h)};d.prototype.tryGet=function(c,s){return R(c,s,this)};var $=n.getHash=function(c,s,h){return p(void 0,c,s,h)};d.prototype.getHash=function(c,s){return $(c,s,this)};var b=n.get=function(c,s){return p(void 0,s._config.hash(c),c,s)};d.prototype.get=function(c,s){return R(s,c,this)};var O=n.has=function(c,s,h){return p(u,c,s,h)!==u};d.prototype.hasHash=function(c,s){return O(c,s,this)};var k=n.has=function(c,s){return O(s._config.hash(c),c,s)};d.prototype.has=function(c){return k(c,this)};var T=function(s,h){return s===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||T,hash:c&&c.hash||_},q,0)},n.empty=n.make();var te=n.isEmpty=function(c){return c&&!!Q(c._root)};d.prototype.isEmpty=function(){return te(this)};var ee=n.modifyHash=function(c,s,h,S){var m={value:S._size},g=S._root._modify(S._editable?S._edit:NaN,S._config.keyEq,0,c,s,h,m);return S.setTree(g,m.value)};d.prototype.modifyHash=function(c,s,h){return ee(h,c,s,this)};var W=n.modify=function(c,s,h){return ee(c,h._config.hash(s),s,h)};d.prototype.modify=function(c,s){return W(s,c,this)};var j=n.setHash=function(c,s,h,S){return ee(f(h),c,s,S)};d.prototype.setHash=function(c,s,h){return j(c,s,h,this)};var he=n.set=function(c,s,h){return j(h._config.hash(c),c,s,h)};d.prototype.set=function(c,s){return he(c,s,this)};var ke=f(u),ie=n.removeHash=function(c,s,h){return ee(ke,c,s,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,s){return ie(c,s,this)};var _e=n.remove=function(c,s){return ie(s._config.hash(c),c,s)};d.prototype.remove=d.prototype.delete=function(c){return _e(c,this)};var Gn=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return Gn(this)};var Kn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return Kn(this)};var Lr=n.mutate=function(c,s){var h=Gn(s);return c(h),Kn(h)};d.prototype.mutate=function(c){return Lr(c,this)};var en=function(s){return s&&Hn(s[0],s[1],s[2],s[3],s[4])},Hn=function(s,h,S,m,g){for(;S<s;){var V=h[S++];if(V&&!Q(V))return qn(V,m,[s,h,S,m,g])}return en(g)},qn=function(s,h,S){switch(s.type){case E:return{value:h(s),rest:S};case B:case z:case J:var m=s.children;return Hn(m.length,m,0,h,S);default:return en(S)}},Cr={done:!0};function tn(c){this.v=c}tn.prototype.next=function(){if(!this.v)return Cr;var c=this.v;return this.v=en(c.rest),c},tn.prototype[Symbol.iterator]=function(){return this};var nn=function(s,h){return new tn(qn(s._root,h))},$r=function(s){return[s.key,s.value]},Ir=n.entries=function(c){return nn(c,$r)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Ir(this)};var Ur=function(s){return s.key},Dr=n.keys=function(c){return nn(c,Ur)};d.prototype.keys=function(){return Dr(this)};var Mr=function(s){return s.value},Or=n.values=d.prototype.values=function(c){return nn(c,Mr)};d.prototype.values=function(){return Or(this)};var jn=n.fold=function(c,s,h){var S=h._root;if(S.type===E)return c(s,S.value,S.key);for(var m=[S.children],g=void 0;g=m.pop();)for(var V=0,w=g.length;V<w;){var A=g[V++];A&&A.type&&(A.type===E?s=c(s,A.value,A.key):m.push(A.children))}return s};d.prototype.fold=function(c,s){return jn(c,s,this)};var kr=n.forEach=function(c,s){return jn(function(h,S,m){return c(S,m,s)},null,s)};d.prototype.forEach=function(c){return kr(c,this)};var Br=n.count=function(c){return c._size};d.prototype.count=function(){return Br(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}),pn=class{constructor(t){I(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return In(this)}toMap(){return new Map(this._map)}},ct=class{constructor(t){if(I(this,"_hamt",Va.empty.beginMutation()),t instanceof ct){let n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(let[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return In(this)}toMap(){return new Map(this._hamt)}};function In(e){return G("recoil_hamt_2020")?new ct(e):new pn(e)}var La={persistentMap:In},Ca=La.persistentMap,$a=Object.freeze({__proto__:null,persistentMap:Ca});function Ia(e,...t){let n=new Set;e:for(let o of e){for(let r of t)if(r.has(o))continue e;n.add(o)}return n}var rt=Ia;function Ua(e,t){let n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Ct=Ua;function Da(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function Ma(e){return{nodeDeps:Ct(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Ct(e.nodeToNodeSubscriptions,t=>new Set(t))}}function sn(e,t,n,o){let{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);let l=i==null?t:rt(t,i);for(let u of l)a.has(u)||a.set(u,new Set),Y(a.get(u)).add(e);if(i){let u=rt(i,t);for(let f of u){if(!a.has(f))return;let _=Y(a.get(f));_.delete(e),_.size===0&&a.delete(f)}}}function Oa(e,t,n,o){var r,a,i,l;let u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||o===((a=u.previousTree)===null||a===void 0?void 0:a.version)||se("Tried to save dependencies to a discarded tree");let f=n.getGraph(o);if(sn(e,t,f),o===((i=u.previousTree)===null||i===void 0?void 0:i.version)){let v=n.getGraph(u.currentTree.version);sn(e,t,v,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var _;let v=(_=u.nextTree)===null||_===void 0?void 0:_.version;if(v!==void 0){let C=n.getGraph(v);sn(e,t,C,f)}}}var ft={cloneGraph:Ma,graph:Da,saveDepsToStore:Oa},ka=0,Ba=()=>ka++,Pa=0,xa=()=>Pa++,Fa=0,za=()=>Fa++,Ft={getNextTreeStateVersion:Ba,getNextStoreID:xa,getNextComponentID:za},{persistentMap:Xn}=$a,{graph:Wa}=ft,{getNextTreeStateVersion:Eo}=Ft;function No(){let e=Eo();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Xn(),nonvalidatedAtoms:Xn()}}function Ga(){let e=No();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Wa()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var wo={makeEmptyTreeState:No,makeEmptyStoreState:Ga,getNextTreeStateVersion:Eo},$t=class{};function Ka(){return new $t}var zt={RetentionZone:$t,retentionZone:Ka};function Ha(e,t){let n=new Set(e);return n.add(t),n}function qa(e,t){let n=new Set(e);return n.delete(t),n}function ja(e,t,n){let o=new Map(e);return o.set(t,n),o}function Za(e,t,n){let o=new Map(e);return o.set(t,n(o.get(t))),o}function Ya(e,t){let n=new Map(e);return n.delete(t),n}function Xa(e,t){let n=new Map(e);return t.forEach(o=>n.delete(o)),n}var Ao={setByAddingToSet:Ha,setByDeletingFromSet:qa,mapBySettingInMap:ja,mapByUpdatingInMap:Za,mapByDeletingFromMap:Ya,mapByDeletingMultipleFromMap:Xa};function*Ja(e,t){let n=0;for(let o of e)t(o,n++)&&(yield o)}var Un=Ja;function Qa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var Vo=Qa,{getNode:ht,getNodeMaybe:ei,recoilValuesForKeys:Jn}=de,{RetentionZone:Qn}=zt,{setByAddingToSet:ti}=Ao,ni=Object.freeze(new Set),vn=class extends Error{};function oi(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};let{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof Qn)r(n);else if(Array.isArray(n))for(let a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;let{retention:a}=e.getState();function i(l){let u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Qn)i(n);else if(Array.isArray(n))for(let l of n)i(l)}}function Dn(e,t,n,o){let r=e.getState();if(r.nodeCleanupFunctions.has(n))return;let a=ht(n),i=oi(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function ri(e,t,n){Dn(e,e.getState().currentTree,t,n)}function ai(e,t){var n;let o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ii(e,t,n){return Dn(e,t,n,"get"),ht(n).get(e,t)}function Lo(e,t,n){return ht(n).peek(e,t)}function si(e,t,n){var o;let r=ei(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ti(e.dirtyAtoms,t)}}function ci(e,t,n,o){let r=ht(n);if(r.set==null)throw new vn(`Attempt to set read-only RecoilValue: ${n}`);let a=r.set;return Dn(e,t,n,"set"),a(e,t,o)}function li(e,t,n){let o=e.getState(),r=e.getGraph(t.version),a=ht(n).nodeType;return Vo({type:a},{loadable:()=>Lo(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return Jn((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,l;return{nodes:Jn(Un(Co(e,t,new Set([n])),u=>u!==n)),components:xt((i=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&i!==void 0?i:[],([u])=>({name:u}))}}})}function Co(e,t,n){let o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var i;o.add(l);let u=(i=a.nodeToNodeSubscriptions.get(l))!==null&&i!==void 0?i:ni;for(let f of u)o.has(f)||r.push(f)}return o}var Ee={getNodeLoadable:ii,peekNodeLoadable:Lo,setNodeValue:ci,initializeNode:ri,cleanUpNode:ai,setUnvalidatedAtomValue_DEPRECATED:si,peekNodeInfo:li,getDownstreamNodes:Co},$o=null;function ui(e){$o=e}function di(){var e;(e=$o)===null||e===void 0||e()}var Io={setInvalidateMemoizedSnapshot:ui,invalidateMemoizedSnapshot:di},{getDownstreamNodes:fi,getNodeLoadable:Uo,setNodeValue:hi}=Ee,{getNextComponentID:_i}=Ft,{getNode:pi,getNodeMaybe:Do}=de,{DefaultValue:Mn}=de,{reactMode:vi}=je,{AbstractRecoilValue:Ri,RecoilState:Si,RecoilValueReadOnly:mi,isRecoilValue:yi}=Le,{invalidateMemoizedSnapshot:gi}=Io;function bi(e,{key:t},n=e.getState().currentTree){var o,r;let a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||se("Tried to read from a discarded tree");let i=Uo(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function Ti(e,t){let n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof Mn?n.delete(r):n.set(r,o)}),n}function Ei(e,t,{key:n},o){if(typeof o=="function"){let r=Uo(e,t,n);if(r.state==="loading"){let a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw se(a),U(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ni(e,t,n){if(n.type==="set"){let{recoilValue:r,valueOrUpdater:a}=n,i=Ei(e,t,r,a),l=hi(e,t,r.key,i);for(let[u,f]of l.entries())Rn(t,u,f)}else if(n.type==="setLoadable"){let{recoilValue:{key:r},loadable:a}=n;Rn(t,r,a)}else if(n.type==="markModified"){let{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;let{recoilValue:{key:r},unvalidatedValue:a}=n,i=Do(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else se(`Unknown action ${n.type}`)}function Rn(e,t,n){n.state==="hasValue"&&n.contents instanceof Mn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Mo(e,t){e.replaceState(n=>{let o=Oo(n);for(let r of t)Ni(e,o,r);return ko(e,o),gi(),o})}function Wt(e,t){if(at.length){let n=at[at.length-1],o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Mo(e,[t])}var at=[];function wi(){let e=new Map;return at.push(e),()=>{for(let[n,o]of e)Mo(n,o);at.pop()!==e&&se("Incorrect order of batch popping")}}function Oo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function ko(e,t){let n=fi(e,t,t.dirtyAtoms);for(let a of n){var o,r;(o=Do(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Bo(e,t,n){Wt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Ai(e,t,n){if(n instanceof Mn)return Bo(e,t,n);Wt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Vi(e,t){Wt(e,{type:"markModified",recoilValue:t})}function Li(e,t,n){Wt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ci(e,{key:t},n,o=null){let r=_i(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Y(a.nodeToComponentSubscriptions.get(t)).set(r,[o!=null?o:"<not captured>",n]);let i=vi();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){let l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{let l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);if(u===void 0||!u.has(r)){se(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t)}}}function $i(e,t){var n;let{currentTree:o}=e.getState(),r=pi(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:mi,AbstractRecoilValue:Ri,RecoilState:Si,getRecoilValueAsLoadable:bi,setRecoilValue:Bo,setRecoilValueLoadable:Ai,markRecoilValueModified:Vi,setUnvalidatedRecoilValue:Li,subscribeToRecoilValue:Ci,isRecoilValue:yi,applyAtomValueWrites:Ti,batchStart:wi,writeLoadableToTreeState:Rn,invalidateDownstreams:ko,copyTreeState:Oo,refreshRecoilValue:$i};function Ii(e,t,n){let o=e.entries(),r=o.next();for(;!r.done;){let a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Ui=Ii,{cleanUpNode:Di}=Ee,{deleteNodeConfigIfPossible:Mi,getNode:Po}=de,{RetentionZone:xo}=zt,Oi=12e4,Fo=new Set;function zo(e,t){let n=e.getState(),o=n.currentTree;if(n.nextTree){se("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let i of t)if(i instanceof xo)for(let l of xi(n,i))r.add(l);else r.add(i);let a=ki(e,r);for(let i of a)Pi(e,o,i)}function ki(e,t){let n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return l(t),a;function l(u){let f=new Set,_=Bi(e,o,u,a,i);for(let y of _){var v;if(Po(y).retainedBy==="recoilRoot"){i.add(y);continue}if(((v=n.retention.referenceCounts.get(y))!==null&&v!==void 0?v:0)>0){i.add(y);continue}if(Wo(y).some(X=>n.retention.referenceCounts.get(X))){i.add(y);continue}let N=r.nodeToNodeSubscriptions.get(y);if(N&&Ui(N,X=>i.has(X))){i.add(y);continue}a.add(y),f.add(y)}let C=new Set;for(let y of f)for(let N of(L=r.nodeDeps.get(y))!==null&&L!==void 0?L:Fo){var L;a.has(N)||C.add(N)}C.size&&l(C)}}function Bi(e,t,n,o,r){let a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)u(Y(n.values().next().value));return i;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;let _=a.nodeToNodeSubscriptions.get(f);if(_)for(let v of _)u(v);l.add(f),n.delete(f),i.push(f)}}function Pi(e,t,n){if(!G("recoil_memory_managament_2020"))return;Di(e,n);let o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);let r=Wo(n);for(let u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let i=o.graphsByVersion.get(t.version);if(i){let u=i.nodeDeps.get(n);if(u!==void 0){i.nodeDeps.delete(n);for(let f of u){var l;(l=i.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Mi(n)}function xi(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Fo}function Wo(e){let t=Po(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof xo?[t]:t}function Fi(e,t){let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):zo(e,new Set([t]))}function zi(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Go(e,t):r.set(t,a)}function Go(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Fi(e,t)}function Wi(e){if(!G("recoil_memory_managament_2020"))return;let t=e.getState();zo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Gi(e){return e===void 0?"recoilRoot":e}var Ie={SUSPENSE_TIMEOUT_MS:Oi,updateRetainCount:zi,updateRetainCountToZero:Go,releaseScheduledRetainablesNow:Wi,retainedByOptionWithDefault:Gi},{unstable_batchedUpdates:Ki}=mo.default,Hi={unstable_batchedUpdates:Ki},{unstable_batchedUpdates:qi}=Hi,ji={unstable_batchedUpdates:qi},{batchStart:Zi}=Se,{unstable_batchedUpdates:Yi}=ji,On=Yi||(e=>e()),Xi=e=>{On=e},Ji=()=>On,Qi=e=>{On(()=>{let t=()=>{};try{t=Zi(),e()}finally{t()}})},Gt={getBatcher:Ji,setBatcher:Xi,batchUpdates:Qi};function*es(e){for(let t of e)for(let n of t)yield n}var Ko=es,Ho=typeof Window=="undefined"||typeof window=="undefined",ts=e=>!Ho&&(e===window||e instanceof Window),ns=typeof navigator!="undefined"&&navigator.product==="ReactNative",_t={isSSR:Ho,isReactNative:ns,isWindow:ts};function os(e,t){let n;return(...o)=>{n||(n={});let r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function rs(e,t){let n,o;return(...r)=>{let a=t(...r);return n===a||(n=a,o=e(...r)),o}}function as(e,t){let n,o;return[(...i)=>{let l=t(...i);return n===l||(n=l,o=e(...i)),o},()=>{n=null}]}var is={memoizeWithArgsHash:os,memoizeOneWithArgsHash:rs,memoizeOneWithArgsHashAndInvalidation:as},{batchUpdates:Sn}=Gt,{initializeNode:ss,peekNodeInfo:cs}=Ee,{graph:ls}=ft,{getNextStoreID:us}=Ft,{DEFAULT_VALUE:ds,recoilValues:eo,recoilValuesForKeys:to}=de,{AbstractRecoilValue:fs,getRecoilValueAsLoadable:hs,setRecoilValue:no,setUnvalidatedRecoilValue:_s}=Se,{updateRetainCount:Tt}=Ie,{setInvalidateMemoizedSnapshot:ps}=Io,{getNextTreeStateVersion:vs,makeEmptyStoreState:Rs}=wo,{isSSR:Ss}=_t,{memoizeOneWithArgsHashAndInvalidation:ms}=is;var We=class{constructor(t,n){I(this,"_store",void 0),I(this,"_refCount",1),I(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),hs(this._store,o))),I(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),I(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];let i=this._store.getState().currentTree;return to(i.dirtyAtoms)}let r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?eo.values():o.isInitialized===!0?to(Ko([r,a])):Un(eo.values(),({key:i})=>!r.has(i)&&!a.has(i))}),I(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),cs(this._store,this._store.getState().currentTree,o))),I(this,"map",o=>{this.checkRefCount_INTERNAL();let r=new lt(this,Sn);return o(r),r}),I(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();let r=new lt(this,Sn);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:us(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{let r=t.graphsByVersion;if(r.has(o))return Y(r.get(o));let a=ls();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw U("Cannot subscribe to Snapshots")}};for(let o of this._store.getState().knownAtoms)ss(this._store,o,"get"),Tt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&se("Attempt to retain() Snapshot that was already released."),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){Ss||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!G("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function qo(e,t,n=!1){let o=e.getState(),r=n?vs():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(xt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ys(e){let t=new We(Rs());return e!=null?t.map(e):t}var[oo,jo]=ms((e,t)=>{var n;let o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:Y(o.previousTree);return new We(qo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ps(jo);function gs(e,t="latest"){let n=oo(e,t);return n.isRetained()?n:(jo(),oo(e,t))}var lt=class extends We{constructor(t,n){super(qo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),I(this,"_batch",void 0),I(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();let a=this.getStore_INTERNAL();this._batch(()=>{Tt(a,o.key,1),no(this.getStore_INTERNAL(),o,r)})}),I(this,"reset",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();this._batch(()=>{Tt(r,o.key,1),no(this.getStore_INTERNAL(),o,ds)})}),I(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();Sn(()=>{for(let[a,i]of o.entries())Tt(r,a,1),_s(r,new fs(a),i)})}),this._batch=n}},Kt={Snapshot:We,MutableSnapshot:lt,freshSnapshot:ys,cloneSnapshot:gs},bs=Kt.Snapshot,Ts=Kt.MutableSnapshot,Es=Kt.freshSnapshot,Ns=Kt.cloneSnapshot,Ht=Object.freeze({__proto__:null,Snapshot:bs,MutableSnapshot:Ts,freshSnapshot:Es,cloneSnapshot:Ns});function ws(...e){let t=new Set;for(let n of e)for(let o of n)t.add(o);return t}var As=ws,{useRef:Vs}=H.default;function Ls(e){let t=Vs(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var ro=Ls,{getNextTreeStateVersion:Cs,makeEmptyStoreState:Zo}=wo,{cleanUpNode:$s,getDownstreamNodes:Is,initializeNode:Us,setNodeValue:Ds,setUnvalidatedAtomValue_DEPRECATED:Ms}=Ee,{graph:Os}=ft,{cloneGraph:ks}=ft,{getNextStoreID:Yo}=Ft,{createMutableSource:cn,reactMode:Xo}=je,{applyAtomValueWrites:Bs}=Se,{releaseScheduledRetainablesNow:Jo}=Ie,{freshSnapshot:Ps}=Ht,{useCallback:xs,useContext:Qo,useEffect:mn,useMemo:Fs,useRef:zs,useState:Ws}=H.default;function Je(){throw U("This component must be used inside a <RecoilRoot> component.")}var er=Object.freeze({storeID:Yo(),getState:Je,replaceState:Je,getGraph:Je,subscribeToTransactions:Je,addTransactionMetadata:Je}),yn=!1;function ao(e){if(yn)throw U("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Jo(e);let n=t.currentTree.version,o=Cs();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,ks(Y(t.graphsByVersion.get(n))))}}var tr=H.default.createContext({current:er}),qt=()=>Qo(tr),nr=H.default.createContext(null);function Gs(){let e=Qo(nr);return e==null&&Cn("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e}function kn(e,t,n){let o=Is(e,n,n.dirtyAtoms);for(let r of o){let a=t.nodeToComponentSubscriptions.get(r);if(a)for(let[i,[l,u]]of a)u(n)}}function or(e){let t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(let[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(let[i,l]of a)l(e);for(let[r,a]of t.transactionSubscriptions)a(e);(!Xo().early||t.suspendedComponentResolvers.size>0)&&(kn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ks(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,or(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):se("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,G("recoil_memory_managament_2020")&&n==null&&Jo(e)}finally{t.commitDepth--}}function Hs({setNotifyBatcherOfChange:e}){let t=qt(),[,n]=Ws([]);return e(()=>n({})),mn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),mn(()=>{wa.enqueueExecution("Batcher",()=>{Ks(t.current)})}),null}function qs(e,t){let n=Zo();return t({set:(o,r)=>{let a=n.currentTree,i=Ds(e,a,o.key,r),l=new Set(i.keys()),u=a.nonvalidatedAtoms.clone();for(let f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:As(a.dirtyAtoms,l),atomValues:Bs(a.atomValues,i),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ms(n.currentTree,a,r)})}}),n}function js(e){let t=Ps(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}var io=0;function Zs({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r,a=L=>{let y=r.current.graphsByVersion;if(y.has(L))return Y(y.get(L));let N=Os();return y.set(L,N),N},i=(L,y)=>{if(y==null){let{transactionSubscriptions:N}=v.current.getState(),X=io++;return N.set(X,L),{release:()=>{N.delete(X)}}}else{let{nodeTransactionSubscriptions:N}=v.current.getState();N.has(y)||N.set(y,new Map);let X=io++;return Y(N.get(y)).set(X,L),{release:()=>{let ne=N.get(y);ne&&(ne.delete(X),ne.size===0&&N.delete(y))}}}},l=L=>{ao(v.current);for(let y of Object.keys(L))Y(v.current.getState().nextTree).transactionMetadata[y]=L[y]},u=L=>{ao(v.current);let y=Y(r.current.nextTree),N;try{yn=!0,N=L(y)}finally{yn=!1}N!==y&&(r.current.nextTree=N,Xo().early&&kn(v.current,r.current,N),Y(f.current)())},f=zs(null),_=xs(L=>{f.current=L},[f]),v=ro(()=>n!=null?n:{storeID:Yo(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:l});n!=null&&(v.current=n),r=ro(()=>e!=null?qs(v.current,e):t!=null?js(t):Zo());let C=Fs(()=>cn==null?void 0:cn(r,()=>r.current.currentTree.version),[r]);return mn(()=>{let L=v.current;for(let y of new Set(L.getState().knownAtoms))Us(L,y,"get");return()=>{for(let y of L.getState().knownAtoms)$s(L,y)}},[v]),H.default.createElement(tr.Provider,{value:v},H.default.createElement(nr.Provider,{value:C},H.default.createElement(Hs,{setNotifyBatcherOfChange:_}),o))}function Ys(e){let{override:t,...n}=e,o=qt();return t===!1&&o.current!==er?e.children:H.default.createElement(Zs,n)}function Xs(){return qt().current.storeID}var be={RecoilRoot:Ys,useStoreRef:qt,useRecoilMutableSource:Gs,useRecoilStoreID:Xs,notifyComponents_FOR_TESTING:kn,sendEndOfBatchNotifications_FOR_TESTING:or};function Js(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Qs=Js,{useEffect:ec,useRef:tc}=H.default;function nc(e){let t=tc();return ec(()=>{t.current=e}),t.current}var rr=nc,{useStoreRef:oc}=be,{SUSPENSE_TIMEOUT_MS:rc}=Ie,{updateRetainCount:Qe}=Ie,{RetentionZone:ac}=zt,{useEffect:ic,useRef:sc}=H.default,{isSSR:so}=_t;function cc(e){if(G("recoil_memory_managament_2020"))return lc(e)}function lc(e){let n=(Array.isArray(e)?e:[e]).map(i=>i instanceof ac?i:i.key),o=oc();ic(()=>{if(!G("recoil_memory_managament_2020"))return;let i=o.current;if(r.current&&!so)window.clearTimeout(r.current),r.current=null;else for(let l of n)Qe(i,l,1);return()=>{for(let l of n)Qe(i,l,-1)}},[o,...n]);let r=sc(),a=rr(n);if(!so&&(a===void 0||!Qs(a,n))){let i=o.current;for(let l of n)Qe(i,l,1);if(a)for(let l of a)Qe(i,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(let l of n)Qe(i,l,-1)},rc)}}var Bn=cc;function uc(){return"<component name not available>"}var pt=uc,{batchUpdates:dc}=Gt,{DEFAULT_VALUE:ar}=de,{currentRendererSupportsUseSyncExternalStore:fc,reactMode:Ze,useMutableSource:hc,useSyncExternalStore:_c}=je,{useRecoilMutableSource:pc,useStoreRef:me}=be,{isRecoilValue:Nd}=Le,{AbstractRecoilValue:gn,getRecoilValueAsLoadable:vt,setRecoilValue:It,setUnvalidatedRecoilValue:vc,subscribeToRecoilValue:Ge}=Se,{useCallback:ue,useEffect:Ke,useMemo:ir,useRef:it,useState:Pn}=H.default,{setByAddingToSet:Rc}=Ao,{isSSR:Sc}=_t;function xn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{let a=n.current.getState().suspendedComponentResolvers;a.add(r),Sc&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:U(`Invalid value of loadable atom "${t.key}"`)}function mc(){let e=pt(),t=me(),[,n]=Pn([]),o=it(new Set);o.current=new Set;let r=it(new Set),a=it(new Map),i=ue(u=>{let f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ue((u,f)=>{a.current.has(f)&&n([])},[]);return Ke(()=>{let u=t.current;rt(o.current,r.current).forEach(f=>{if(a.current.has(f)){Cn(`Double subscription to RecoilValue "${f}"`);return}let _=Ge(u,new gn(f),C=>l(C,f),e);a.current.set(f,_),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),rt(r.current,o.current).forEach(f=>{i(f)}),r.current=o.current}),Ke(()=>{let u=a.current;return rt(o.current,new Set(u.keys())).forEach(f=>{let _=Ge(t.current,new gn(f),v=>l(v,f),e);u.set(f,_)}),()=>u.forEach((f,_)=>i(_))},[e,t,i,l]),ir(()=>{function u(y){return N=>{It(t.current,y,N)}}function f(y){return()=>It(t.current,y,ar)}function _(y){var N;o.current.has(y.key)||(o.current=Rc(o.current,y.key));let X=t.current.getState();return vt(t.current,y,Ze().early&&(N=X.nextTree)!==null&&N!==void 0?N:X.currentTree)}function v(y){let N=_(y);return xn(N,y,t)}function C(y){return[v(y),u(y)]}function L(y){return[_(y),u(y)]}return{getRecoilValue:v,getRecoilValueLoadable:_,getRecoilState:C,getRecoilStateLoadable:L,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}var yc={current:0};function gc(e){let t=me(),n=pt(),o=ue(()=>{var l;let u=t.current,f=u.getState(),_=Ze().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:vt(u,e,_),key:e.key}},[t,e]),r=ue(l=>{let u;return()=>{var f,_;let v=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(v.loadable)&&((_=u)===null||_===void 0?void 0:_.key)===v.key?u:(u=v,v)}},[]),a=ir(()=>r(o),[o,r]),i=ue(l=>{let u=t.current;return Ge(u,e,l,n).release},[t,e,n]);return _c(i,a,a).loadable}function bc(e){let t=me(),n=ue(()=>{var f;let _=t.current,v=_.getState(),C=Ze().early&&(f=v.nextTree)!==null&&f!==void 0?f:v.currentTree;return vt(_,e,C)},[t,e]),o=ue(()=>n(),[n]),r=pt(),a=ue((f,_)=>{let v=t.current;return Ge(v,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return _();let L=n();u.current.is(L)||_(),u.current=L},r).release},[t,e,r,n]),i=pc();if(i==null)throw U("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=hc(i,o,a),u=it(l);return Ke(()=>{u.current=l}),l}function bn(e){let t=me(),n=pt(),o=ue(()=>{var u;let f=t.current,_=f.getState(),v=Ze().early&&(u=_.nextTree)!==null&&u!==void 0?u:_.currentTree;return vt(f,e,v)},[t,e]),r=ue(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ue(u=>{let f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);Ke(()=>{let u=Ge(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);let[i,l]=Pn(r);return i.key!==e.key?r().loadable:i.loadable}function Tc(e){let t=me(),[,n]=Pn([]),o=pt(),r=ue(()=>{var l;let u=t.current,f=u.getState(),_=Ze().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return vt(u,e,_)},[t,e]),a=r(),i=it(a);return Ke(()=>{i.current=a}),Ke(()=>{let l=t.current,u=l.getState(),f=Ge(l,e,v=>{var C;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let L=r();(C=i.current)!==null&&C!==void 0&&C.is(L)||n(L),i.current=L},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var _;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let v=r();(_=i.current)!==null&&_!==void 0&&_.is(v)||n(v),i.current=v}return f.release},[o,r,e,t]),a}function Fn(e){return G("recoil_memory_managament_2020")&&Bn(e),{TRANSITION_SUPPORT:bn,SYNC_EXTERNAL_STORE:fc()?gc:bn,MUTABLE_SOURCE:bc,LEGACY:Tc}[Ze().mode](e)}function sr(e){let t=me(),n=Fn(e);return xn(n,e,t)}function jt(e){let t=me();return ue(n=>{It(t.current,e,n)},[t,e])}function Ec(e){let t=me();return ue(()=>{It(t.current,e,ar)},[t,e])}function Nc(e){return[sr(e),jt(e)]}function wc(e){return[Fn(e),jt(e)]}function Ac(){let e=me();return(t,n={})=>{dc(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>vc(e.current,new gn(r),o))})}}function cr(e){return G("recoil_memory_managament_2020")&&Bn(e),bn(e)}function lr(e){let t=me(),n=cr(e);return xn(n,e,t)}function Vc(e){return[lr(e),jt(e)]}var Lc={recoilComponentGetRecoilValueCount_FOR_TESTING:yc,useRecoilInterface:mc,useRecoilState:Nc,useRecoilStateLoadable:wc,useRecoilValue:sr,useRecoilValueLoadable:Fn,useResetRecoilState:Ec,useSetRecoilState:jt,useSetUnvalidatedAtomValues:Ac,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:cr,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:lr,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Vc};function Cc(e,t){let n=new Map;for(let[o,r]of e)t(r,o)&&n.set(o,r);return n}var $c=Cc;function Ic(e,t){let n=new Set;for(let o of e)t(o)&&n.add(o);return n}var Uc=Ic;function Dc(...e){let t=new Map;for(let n=0;n<e.length;n++){let o=e[n].keys(),r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Mc=Dc,{batchUpdates:Oc}=Gt,{DEFAULT_VALUE:kc,getNode:ur,nodes:Bc}=de,{useStoreRef:zn}=be,{AbstractRecoilValue:Pc,setRecoilValueLoadable:xc}=Se,{SUSPENSE_TIMEOUT_MS:Fc}=Ie,{cloneSnapshot:Ut}=Ht,{useCallback:Zt,useEffect:dr,useRef:co,useState:zc}=H.default,{isSSR:lo}=_t;function Yt(e){let t=zn();dr(()=>t.current.subscribeToTransactions(e).release,[e,t])}function uo(e){let t=e.atomValues.toMap(),n=Ct($c(t,(o,r)=>{let i=ur(r).persistence_UNSTABLE;return i!=null&&i.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Mc(e.nonvalidatedAtoms.toMap(),n)}function Wc(e){Yt(Zt(t=>{let n=t.getState().previousTree,o=t.getState().currentTree;n||(se("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let r=uo(o),a=uo(n),i=Ct(Bc,u=>{var f,_,v,C;return{persistence_UNSTABLE:{type:(f=(_=u.persistence_UNSTABLE)===null||_===void 0?void 0:_.type)!==null&&f!==void 0?f:"none",backButton:(v=(C=u.persistence_UNSTABLE)===null||C===void 0?void 0:C.backButton)!==null&&v!==void 0?v:!1}}}),l=Uc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Gc(e){Yt(Zt(t=>{let n=Ut(t,"latest"),o=Ut(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Kc(){let e=zn(),[t,n]=zc(()=>Ut(e.current)),o=rr(t),r=co(),a=co();if(Yt(Zt(l=>n(Ut(l)),[])),dr(()=>{let l=t.retain();if(r.current&&!lo){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!lo){if(r.current){var i;window.clearTimeout(r.current),r.current=null,(i=a.current)===null||i===void 0||i.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Fc)}return t}function fr(e,t){var n;let o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Oc(()=>{let i=new Set;for(let f of[r.atomValues.keys(),a.atomValues.keys()])for(let _ of f){var l,u;((l=r.atomValues.get(_))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(_))===null||u===void 0?void 0:u.contents)&&ur(_).shouldRestoreFromSnapshots&&i.add(_)}i.forEach(f=>{xc(e,new Pc(f),a.atomValues.has(f)?Y(a.atomValues.get(f)):kc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Hc(){let e=zn();return Zt(t=>fr(e.current,t),[e])}var hr={useRecoilSnapshot:Kc,gotoSnapshot:fr,useGotoRecoilSnapshot:Hc,useRecoilTransactionObserver:Gc,useTransactionObservation_DEPRECATED:Wc,useTransactionSubscription_DEPRECATED:Yt},{peekNodeInfo:qc}=Ee,{useStoreRef:jc}=be;function Zc(){let e=jc();return({key:t})=>qc(e.current,e.current.getState().currentTree,t)}var Yc=Zc,{reactMode:Xc}=je,{RecoilRoot:Jc,useStoreRef:Qc}=be,{useMemo:el}=H.default;function tl(){Xc().mode;let e=Qc().current;return el(()=>{function t({children:n}){return H.default.createElement(Jc,{store_INTERNAL:e},n)}return t},[e])}var nl=tl,{loadableWithValue:ol}=dt,{initializeNode:rl}=Ee,{DEFAULT_VALUE:al,getNode:il}=de,{copyTreeState:sl,getRecoilValueAsLoadable:cl,invalidateDownstreams:ll,writeLoadableToTreeState:ul}=Se;function fo(e){return il(e.key).nodeType==="atom"}var Tn=class{constructor(t,n){I(this,"_store",void 0),I(this,"_treeState",void 0),I(this,"_changes",void 0),I(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!fo(o))throw U("Reading selectors within atomicUpdate is not supported");let r=cl(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:U(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),I(this,"set",(o,r)=>{if(!fo(o))throw U("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){let a=this.get(o);this._changes.set(o.key,r(a))}else rl(this._store,o.key,"set"),this._changes.set(o.key,r)}),I(this,"reset",o=>{this.set(o,al)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;let t=sl(this._treeState);for(let[n,o]of this._changes)ul(t,n,ol(o));return ll(this._store,t),t}};function dl(e){return t=>{e.replaceState(n=>{let o=new Tn(e,n);return t(o),o.newTreeState_INTERNAL()})}}var fl={atomicUpdater:dl},hl=fl.atomicUpdater,_r=Object.freeze({__proto__:null,atomicUpdater:hl});function _l(e,t){if(!e)throw new Error(t)}var pl=_l,ot=pl,{atomicUpdater:vl}=_r,{batchUpdates:Rl}=Gt,{DEFAULT_VALUE:Sl}=de,{useStoreRef:ml}=be,{refreshRecoilValue:yl,setRecoilValue:ho}=Se,{cloneSnapshot:gl}=Ht,{gotoSnapshot:bl}=hr,{useCallback:Tl}=H.default,Dt=class{},El=new Dt;function pr(e,t,n,o){let r=El,a;if(Rl(()=>{let l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw U(l);let u=Vo({...o!=null?o:{},set:(_,v)=>ho(e,_,v),reset:_=>ho(e,_,Sl),refresh:_=>yl(e,_),gotoSnapshot:_=>bl(e,_),transact_UNSTABLE:_=>vl(e)(_)},{snapshot:()=>{let _=gl(e);return a=_.retain(),_}}),f=t(u);if(typeof f!="function")throw U(l);r=f(...n)}),r instanceof Dt&&ot(!1),K(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var i;(i=a)===null||i===void 0||i()}return r}function Nl(e,t){let n=ml();return Tl((...o)=>pr(n.current,e,o),t!=null?[...t,n]:void 0)}var vr={recoilCallback:pr,useRecoilCallback:Nl},{useStoreRef:wl}=be,{refreshRecoilValue:Al}=Se,{useCallback:Vl}=H.default;function Ll(e){let t=wl();return Vl(()=>{let n=t.current;Al(n,e)},[e,t])}var Cl=Ll,{atomicUpdater:$l}=_r,{useStoreRef:Il}=be,{useMemo:Ul}=H.default;function Dl(e,t){let n=Il();return Ul(()=>(...o)=>{$l(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Ml=Dl,En=class{constructor(t){I(this,"value",void 0),this.value=t}},Ol={WrappedValue:En},kl=Ol.WrappedValue,Rr=Object.freeze({__proto__:null,WrappedValue:kl}),{isFastRefreshEnabled:Bl}=je,Mt=class extends Error{},Nn=class{constructor(t){var n,o,r;I(this,"_name",void 0),I(this,"_numLeafs",void 0),I(this,"_root",void 0),I(this,"_onHit",void 0),I(this,"_onSet",void 0),I(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;let r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){let r=()=>{var a,i,l,u;let f,_;for(let[X,ne]of t){var v,C,L;let E=this._root;if((E==null?void 0:E.type)==="leaf")throw this.invalidCacheError();let B=f;if(f=B?B.branches.get(_):E,f=(v=f)!==null&&v!==void 0?v:{type:"branch",nodeKey:X,parent:B,branches:new Map,branchKey:_},f.type!=="branch"||f.nodeKey!==X)throw this.invalidCacheError();B==null||B.branches.set(_,f),o==null||(C=o.onNodeVisit)===null||C===void 0||C.call(o,f),_=this._mapNodeValue(ne),this._root=(L=this._root)!==null&&L!==void 0?L:f}let y=f?(a=f)===null||a===void 0?void 0:a.branches.get(_):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==_))throw this.invalidCacheError();let N={type:"leaf",value:n,parent:f,branchKey:_};(i=f)===null||i===void 0||i.branches.set(_,N),this._root=(l=this._root)!==null&&l!==void 0?l:N,this._numLeafs++,this._onSet(N),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,N)};try{r()}catch(a){if(a instanceof Mt)this.clear(),r();else throw a}}delete(t){let n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let t=Bl()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw se(t+(this._name!=null?` - ${this._name}`:"")),new Mt}},Pl={TreeCache:Nn},xl=Pl.TreeCache,Sr=Object.freeze({__proto__:null,TreeCache:xl}),wn=class{constructor(t){var n;I(this,"_maxSize",void 0),I(this,"_size",void 0),I(this,"_head",void 0),I(this,"_tail",void 0),I(this,"_map",void 0),I(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){let n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){let o=this._keyMapper(t);this._map.get(o)&&this.delete(t);let a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let t=this.tail();t&&this.delete(t.key)}delete(t){let n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;let o=Y(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Fl={LRUCache:wn},zl=Fl.LRUCache,mr=Object.freeze({__proto__:null,LRUCache:zl}),{LRUCache:Wl}=mr,{TreeCache:Gl}=Sr;function Kl({name:e,maxSize:t,mapNodeValue:n=o=>o}){let o=new Wl({maxSize:t}),r=new Gl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{let i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var _o=Kl;function Re(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw U("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Re(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Re(e.toJSON(n),t,n);if(e instanceof Map){let r={};for(let[a,i]of e)r[typeof a=="string"?a:Re(a,t)]=i;return Re(r,t,n)}return e instanceof Set?Re(Array.from(e).sort((r,a)=>Re(r,t).localeCompare(Re(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Re(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Re(r,t)}:${Re(e[r],t,r)}`).join(",")}}`}function Hl(e,t={allowFunctions:!1}){return Re(e,t)}var Xt=Hl,{TreeCache:ql}=Sr,St={equality:"reference",eviction:"keep-all",maxSize:1/0};function jl({equality:e=St.equality,eviction:t=St.eviction,maxSize:n=St.maxSize}=St,o){let r=Zl(e);return Yl(t,n,r,o)}function Zl(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw U(`Unrecognized equality policy ${e}`)}function Yl(e,t,n,o){switch(e){case"keep-all":return new ql({name:o,mapNodeValue:n});case"lru":return _o({name:o,maxSize:Y(t),mapNodeValue:n});case"most-recent":return _o({name:o,maxSize:1,mapNodeValue:n})}throw U(`Unrecognized eviction policy ${e}`)}var Xl=jl;var{isReactNative:wd,isWindow:Ad}=_t;function Jl(e){return()=>null}var Ql={startPerfBlock:Jl},{isLoadable:eu,loadableWithError:mt,loadableWithPromise:tu,loadableWithValue:ln}=dt,{WrappedValue:yr}=Rr,{getNodeLoadable:yt,peekNodeLoadable:nu,setNodeValue:ou}=Ee,{saveDepsToStore:ru}=ft,{DEFAULT_VALUE:au,getConfigDeletionHandler:iu,getNode:su,registerNode:po}=de,{isRecoilValue:cu}=Le,{markRecoilValueModified:vo}=Se,{retainedByOptionWithDefault:lu}=Ie,{recoilCallback:uu}=vr,{startPerfBlock:du}=Ql,Ot=class{},et=new Ot,tt=[],gt=new Map,fu=(()=>{let e=0;return()=>e++})();function gr(e){let t=null,{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,l=Xl(r!=null?r:{equality:"reference",eviction:"keep-all"},n),u=lu(e.retainedBy_UNSTABLE),f=new Map,_=0;function v(){return!G("recoil_memory_managament_2020")||_>0}function C(d){return d.getState().knownSelectors.add(n),_++,()=>{_--}}function L(){return iu(n)!==void 0&&!v()}function y(d,p,R,$,b){De(p,$,b),N(d,R)}function N(d,p){fe(d,p)&&re(d),ne(p,!0)}function X(d,p){fe(d,p)&&(Y(F(d)).stateVersions.clear(),ne(p,!1))}function ne(d,p){let R=gt.get(d);if(R!=null){for(let $ of R)vo($,Y(t));p&&gt.delete(d)}}function E(d,p){let R=gt.get(p);R==null&&gt.set(p,R=new Set),R.add(d)}function B(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),et;let T=ln(k);return y(d,R,b,T,$),k}).catch(k=>{if(!v())throw re(d),et;if(K(k))return J(d,k,R,$,b,O);let T=mt(k);throw y(d,R,b,T,$),k})}function J(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),et;O.loadingDepKey!=null&&O.loadingDepPromise===p?R.atomValues.set(O.loadingDepKey,ln(k)):d.getState().knownSelectors.forEach(W=>{R.atomValues.delete(W)});let T=Q(d,R);if(T&&T.state!=="loading"){if((fe(d,b)||F(d)==null)&&N(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!fe(d,b)){let W=ye(d,R);if(W!=null)return W.loadingLoadable.contents}let[te,ee]=q(d,R,b);if(te.state!=="loading"&&y(d,R,b,te,ee),te.state==="hasError")throw te.contents;return te.contents}).catch(k=>{if(k instanceof Ot)throw et;if(!v())throw re(d),et;let T=mt(k);throw y(d,R,b,T,$),k})}function z(d,p,R,$){var b,O,k,T;if(fe(d,$)||p.version===((b=d.getState())===null||b===void 0||(O=b.currentTree)===null||O===void 0?void 0:O.version)||p.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var te,ee,W;ru(n,R,d,(te=(ee=d.getState())===null||ee===void 0||(W=ee.nextTree)===null||W===void 0?void 0:W.version)!==null&&te!==void 0?te:d.getState().currentTree.version)}for(let j of R)i.add(j)}function q(d,p,R){let $=du(n),b=!0,O=!0,k=()=>{$(),O=!1},T,te=!1,ee,W={loadingDepKey:null,loadingDepPromise:null},j=new Map;function he({key:ie}){let _e=yt(d,p,ie);switch(j.set(ie,_e),b||(z(d,p,new Set(j.keys()),R),X(d,R)),_e.state){case"hasValue":return _e.contents;case"hasError":throw _e.contents;case"loading":throw W.loadingDepKey=ie,W.loadingDepPromise=_e.contents,_e.contents}throw U("Invalid Loadable state")}let ke=ie=>(..._e)=>{if(O)throw U("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&ot(!1),uu(d,ie,_e,{node:t})};try{T=o({get:he,getCallback:ke}),T=cu(T)?he(T):T,eu(T)&&(T.state==="hasError"&&(te=!0),T=T.contents),K(T)?T=B(d,T,p,j,R,W).finally(k):k(),T=T instanceof yr?T.value:T}catch(ie){T=ie,K(T)?T=J(d,T,p,j,R,W).finally(k):(te=!0,k())}return te?ee=mt(T):K(T)?ee=tu(T):ee=ln(T),b=!1,we(d,R,j),z(d,p,new Set(j.keys()),R),[ee,j]}function Q(d,p){let R=p.atomValues.get(n);if(R!=null)return R;let $=new Set;try{R=l.get(O=>(typeof O!="string"&&ot(!1),yt(d,p,O).contents),{onNodeVisit:O=>{O.type==="branch"&&O.nodeKey!==n&&$.add(O.nodeKey)}})}catch(O){throw U(`Problem with cache lookup for selector "${n}": ${O.message}`)}if(R){var b;p.atomValues.set(n,R),z(d,p,$,(b=F(d))===null||b===void 0?void 0:b.executionID)}return R}function ce(d,p){let R=Q(d,p);if(R!=null)return re(d),R;let $=ye(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&E(d,$.executionID),$.loadingLoadable}let O=fu(),[k,T]=q(d,p,O);return k.state==="loading"?(ae(d,O,k,T,p),E(d,O)):(re(d),De(p,k,T)),k}function ye(d,p){let R=Ko([f.has(d)?[Y(f.get(d))]:[],xt(Un(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(let[O,k]of b)if(!yt(d,p,O).is(k))return!0;return!1}for(let b of R){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function F(d){return f.get(d)}function ae(d,p,R,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:R,stateVersions:new Map([[b.version,!0]])})}function we(d,p,R){if(fe(d,p)){let $=F(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=R)}}function re(d){f.delete(d)}function fe(d,p){var R;return p===((R=F(d))===null||R===void 0?void 0:R.executionID)}function Ue(d){return Array.from(d.entries()).map(([p,R])=>[p,R.contents])}function De(d,p,R){d.atomValues.set(n,p);try{l.set(Ue(R),p)}catch($){throw U(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ge(d){if(tt.includes(n)){let p=`Recoil selector has circular dependencies: ${tt.slice(tt.indexOf(n)).join(" \u2192 ")}`;return mt(U(p))}tt.push(n);try{return d()}finally{tt.pop()}}function Me(d,p){let R=p.atomValues.get(n);return R!=null?R:l.get($=>{var b;return typeof $!="string"&&ot(!1),(b=nu(d,p,$))===null||b===void 0?void 0:b.contents})}function Oe(d,p){return ge(()=>ce(d,p))}function P(d){d.atomValues.delete(n)}function x(d,p){t==null&&ot(!1);for(let $ of i){var R;let b=su($);(R=b.clearCache)===null||R===void 0||R.call(b,d,p)}i.clear(),P(p),l.clear(),vo(d,t)}return a!=null?t=po({key:n,nodeType:"selector",peek:Me,get:Oe,set:(p,R,$)=>{let b=!1,O=new Map;function k({key:W}){if(b)throw U("Recoil: Async selector sets are not currently supported.");let j=yt(p,R,W);if(j.state==="hasValue")return j.contents;if(j.state==="loading"){let he=`Getting value of asynchronous atom or selector "${W}" in a pending state while setting selector "${n}" is not yet supported.`;throw se(he),U(he)}else throw j.contents}function T(W,j){if(b){let ie="Recoil: Async selector sets are not currently supported.";throw se(ie),U(ie)}let he=typeof j=="function"?j(k(W)):j;ou(p,R,W.key,he).forEach((ie,_e)=>O.set(_e,ie))}function te(W){T(W,au)}let ee=a({set:T,get:k,reset:te},$);if(ee!==void 0)throw K(ee)?U("Recoil: Async selector sets are not currently supported."):U("Recoil: selector set should be a void function.");return b=!0,O},init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=po({key:n,nodeType:"selector",peek:Me,get:Oe,init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}gr.value=e=>new yr(e);var He=gr,{isLoadable:hu,loadableWithError:un,loadableWithPromise:dn,loadableWithValue:Pe}=dt,{WrappedValue:br}=Rr,{peekNodeInfo:_u}=Ee,{DEFAULT_VALUE:Ae,DefaultValue:Te,getConfigDeletionHandler:Tr,registerNode:pu,setConfigDeletionHandler:vu}=de,{isRecoilValue:Ru}=Le,{getRecoilValueAsLoadable:Su,markRecoilValueModified:mu,setRecoilValue:Ro,setRecoilValueLoadable:yu}=Se,{retainedByOptionWithDefault:gu}=Ie,nt=e=>e instanceof br?e.value:e;function bu(e){let{key:t,persistence_UNSTABLE:n}=e,o=gu(e.retainedBy_UNSTABLE),r=0;function a(E){return dn(E.then(B=>(i=Pe(B),B)).catch(B=>{throw i=un(B),B}))}let i=K(e.default)?a(e.default):hu(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Pe(nt(e.default));i.contents;let l,u=new Map;function f(E){return E}function _(E,B){let J=B.then(z=>{var q,Q;return((Q=((q=E.getState().nextTree)!==null&&q!==void 0?q:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&Ro(E,ne,z),z}).catch(z=>{var q,Q;throw((Q=((q=E.getState().nextTree)!==null&&q!==void 0?q:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&yu(E,ne,un(z)),z});return J}function v(E,B,J){var z;r++;let q=()=>{var F;r--,(F=u.get(E))===null||F===void 0||F.forEach(ae=>ae()),u.delete(E)};if(E.getState().knownAtoms.add(t),i.state==="loading"){let F=()=>{var ae;((ae=E.getState().nextTree)!==null&&ae!==void 0?ae:E.getState().currentTree).atomValues.has(t)||mu(E,ne)};i.contents.finally(F)}let Q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(Q!=null){let fe=function(P){if(ae&&P.key===t){let x=F;return x instanceof Te?C(E,B):K(x)?dn(x.then(d=>d instanceof Te?i.toPromise():d)):Pe(x)}return Su(E,P)},Ue=function(P){return fe(P).toPromise()},De=function(P){var x;let d=_u(E,(x=E.getState().nextTree)!==null&&x!==void 0?x:E.getState().currentTree,P.key);return ae&&P.key===t&&!(F instanceof Te)?{...d,isSet:!0,loadable:fe(P)}:d},F=Ae,ae=!0,we=!1,re=null,ge=P=>x=>{if(ae){let d=fe(ne),p=d.state==="hasValue"?d.contents:Ae;F=typeof x=="function"?x(p):x,K(F)&&(F=F.then(R=>(re={effect:P,value:R},R)))}else{if(K(x))throw U("Setting atoms to async values is not implemented.");typeof x!="function"&&(re={effect:P,value:nt(x)}),Ro(E,ne,typeof x=="function"?d=>{let p=nt(x(d));return re={effect:P,value:p},p}:nt(x))}},Me=P=>()=>ge(P)(Ae),Oe=P=>x=>{var d;let{release:p}=E.subscribeToTransactions(R=>{var $;let{currentTree:b,previousTree:O}=R.getState();O||(se("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),O=b);let k=($=b.atomValues.get(t))!==null&&$!==void 0?$:i;if(k.state==="hasValue"){var T,te,ee,W;let j=k.contents,he=(T=O.atomValues.get(t))!==null&&T!==void 0?T:i,ke=he.state==="hasValue"?he.contents:Ae;((te=re)===null||te===void 0?void 0:te.effect)!==P||((ee=re)===null||ee===void 0?void 0:ee.value)!==j?x(j,ke,!b.atomValues.has(t)):((W=re)===null||W===void 0?void 0:W.effect)===P&&(re=null)}},t);u.set(E,[...(d=u.get(E))!==null&&d!==void 0?d:[],p])};for(let P of Q)try{let x=P({node:ne,storeID:E.storeID,parentStoreID_UNSTABLE:E.parentStoreID,trigger:J,setSelf:ge(P),resetSelf:Me(P),onSet:Oe(P),getPromise:Ue,getLoadable:fe,getInfo_UNSTABLE:De});if(x!=null){var ce;u.set(E,[...(ce=u.get(E))!==null&&ce!==void 0?ce:[],x])}}catch(x){F=x,we=!0}if(ae=!1,!(F instanceof Te)){var ye;let P=we?un(F):K(F)?dn(_(E,F)):Pe(nt(F));P.contents,B.atomValues.set(t,P),(ye=E.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return q}function C(E,B){var J,z;return(J=(z=B.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&J!==void 0?J:i}function L(E,B){if(B.atomValues.has(t))return Y(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return Cn(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),i;let J=B.nonvalidatedAtoms.get(t),z=n.validator(J,Ae);return l=z instanceof Te?i:Pe(z),l}else return i}function y(){l=void 0}function N(E,B,J){if(B.atomValues.has(t)){let z=Y(B.atomValues.get(t));if(z.state==="hasValue"&&J===z.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof Te)return new Map;return l=void 0,new Map().set(t,Pe(J))}function X(){return Tr(t)!==void 0&&r<=0}let ne=pu({key:t,nodeType:"atom",peek:C,get:L,set:N,init:v,invalidate:y,shouldDeleteConfigOnRelease:X,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function Wn(e){let{...t}=e,n="default"in e?e.default:new Promise(()=>{});return Ru(n)?Tu({...t,default:n}):bu({...t,default:n})}function Tu(e){let t=Wn({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Te?o:Y(e.persistence_UNSTABLE).validator(o,Ae)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=He({key:`${e.key}__withFallback`,get:({get:o})=>{let r=o(t);return r instanceof Te?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return vu(n.key,Tr(e.key)),n}Wn.value=e=>new br(e);var Er=Wn,An=class{constructor(t){var n;I(this,"_map",void 0),I(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}},Eu={MapCache:An},Nu=Eu.MapCache,wu=Object.freeze({__proto__:null,MapCache:Nu}),{LRUCache:So}=mr,{MapCache:Au}=wu,bt={equality:"reference",eviction:"none",maxSize:1/0};function Vu({equality:e=bt.equality,eviction:t=bt.eviction,maxSize:n=bt.maxSize}=bt){let o=Lu(e);return Cu(t,n,o)}function Lu(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw U(`Unrecognized equality policy ${e}`)}function Cu(e,t,n){switch(e){case"keep-all":return new Au({mapKey:n});case"lru":return new So({mapKey:n,maxSize:Y(t)});case"most-recent":return new So({mapKey:n,maxSize:1})}throw U(`Unrecognized eviction policy ${e}`)}var Nr=Vu,{setConfigDeletionHandler:$u}=de;function Iu(e){var t,n;let o=Nr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,i;let l=o.get(r);if(l!=null)return l;let{cachePolicyForParams_UNSTABLE:u,...f}=e,_="default"in e?e.default:new Promise(()=>{}),v=Er({...f,key:`${e.key}__${(a=Xt(r))!==null&&a!==void 0?a:"void"}`,default:typeof _=="function"?_(r):_,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(i=e.effects)!==null&&i!==void 0?i:e.effects_UNSTABLE});return o.set(r,v),$u(v.key,()=>{o.delete(r)}),v}}var Uu=Iu,{setConfigDeletionHandler:Du}=de,Mu=0;function Ou(e){var t,n;let o=Nr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(C){throw U(`Problem with cache lookup for selector ${e.key}: ${C.message}`)}if(i!=null)return i;let l=`${e.key}__selectorFamily/${(a=Xt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Mu++}`,u=C=>e.get(r)(C),f=e.cachePolicy_UNSTABLE,_=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,v;if(e.set!=null){let C=e.set;v=He({key:l,get:u,set:(y,N)=>C(r)(y,N),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_})}else v=He({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_});return o.set(r,v),Du(v.key,()=>{o.delete(r)}),v}}var Ne=Ou,ku=Ne({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Bu(e){return ku(e)}var Pu=Bu,xu=Ne({key:"__error",get:e=>()=>{throw U(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Fu(e){return xu(e)}var zu=Fu;function Wu(e){return e}var Gu=Wu,{loadableWithError:wr,loadableWithPromise:Ar,loadableWithValue:Vr}=dt;function Jt(e,t){let n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(let[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function Ku(e){return e!=null&&!K(e)}function Qt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Vn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function xe(e,t,n){let o=n.map((r,a)=>r==null?Vr(t[a]):K(r)?Ar(r):wr(r));return Vn(e,o)}function Hu(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}var qu=Ne({key:"__waitForNone",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return xe(e,o,r)},dangerouslyAllowMutability:!0}),ju=Ne({key:"__waitForAny",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.some(a=>!K(a))?xe(e,o,r):new Promise(a=>{for(let[i,l]of r.entries())K(l)&&l.then(u=>{o[i]=u,r[i]=void 0,a(xe(e,o,r))}).catch(u=>{r[i]=u,a(xe(e,o,r))})})},dangerouslyAllowMutability:!0}),Zu=Ne({key:"__waitForAll",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);if(r.every(i=>i==null))return Vn(e,o);let a=r.find(Ku);if(a!=null)throw a;return Promise.all(r).then(i=>Vn(e,Hu(o,i)))},dangerouslyAllowMutability:!0}),Yu=Ne({key:"__waitForAllSettled",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.every(a=>!K(a))?xe(e,o,r):Promise.all(r.map((a,i)=>K(a)?a.then(l=>{o[i]=l,r[i]=void 0}).catch(l=>{o[i]=void 0,r[i]=l}):null)).then(()=>xe(e,o,r))},dangerouslyAllowMutability:!0}),Xu=Ne({key:"__noWait",get:e=>({get:t})=>{try{return He.value(Vr(t(e)))}catch(n){return He.value(K(n)?Ar(n):wr(n))}},dangerouslyAllowMutability:!0}),Ju={waitForNone:qu,waitForAny:ju,waitForAll:Zu,waitForAllSettled:Yu,noWait:Xu},{RecoilLoadable:Qu}=dt,{DefaultValue:ed}=de,{RecoilRoot:td,useRecoilStoreID:nd}=be,{isRecoilValue:od}=Le,{retentionZone:rd}=zt,{freshSnapshot:ad}=Ht,{useRecoilState:id,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:sd,useRecoilStateLoadable:cd,useRecoilValue:ld,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ud,useRecoilValueLoadable:dd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:fd,useResetRecoilState:hd,useSetRecoilState:_d}=Lc,{useGotoRecoilSnapshot:pd,useRecoilSnapshot:vd,useRecoilTransactionObserver:Rd}=hr,{useRecoilCallback:Sd}=vr,{noWait:md,waitForAll:yd,waitForAllSettled:gd,waitForAny:bd,waitForNone:Td}=Ju,M={DefaultValue:ed,isRecoilValue:od,RecoilLoadable:Qu,RecoilEnv:qe,RecoilRoot:td,useRecoilStoreID:nd,useRecoilBridgeAcrossReactRoots_UNSTABLE:nl,atom:Er,selector:He,atomFamily:Uu,selectorFamily:Ne,constSelector:Pu,errorSelector:zu,readOnlySelector:Gu,noWait:md,waitForNone:Td,waitForAny:bd,waitForAll:yd,waitForAllSettled:gd,useRecoilValue:ld,useRecoilValueLoadable:dd,useRecoilState:id,useRecoilStateLoadable:cd,useSetRecoilState:_d,useResetRecoilState:hd,useGetRecoilValueInfo_UNSTABLE:Yc,useRecoilRefresher_UNSTABLE:Cl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:fd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ud,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:sd,useRecoilCallback:Sd,useRecoilTransaction_UNSTABLE:Ml,useGotoRecoilSnapshot:pd,useRecoilSnapshot:vd,useRecoilTransactionObserver_UNSTABLE:Rd,snapshot_UNSTABLE:ad,useRetain:Bn,retentionZone:rd},Vd=M.DefaultValue,Ld=M.isRecoilValue,Cd=M.RecoilLoadable,$d=M.RecoilEnv,Id=M.RecoilRoot,Ud=M.useRecoilStoreID,Dd=M.useRecoilBridgeAcrossReactRoots_UNSTABLE,Md=M.atom,Od=M.selector,kd=M.atomFamily,Bd=M.selectorFamily,Pd=M.constSelector,xd=M.errorSelector,Fd=M.readOnlySelector,zd=M.noWait,Wd=M.waitForNone,Gd=M.waitForAny,Kd=M.waitForAll,Hd=M.waitForAllSettled,qd=M.useRecoilValue,jd=M.useRecoilValueLoadable,Zd=M.useRecoilState,Yd=M.useRecoilStateLoadable,Xd=M.useSetRecoilState,Jd=M.useResetRecoilState,Qd=M.useGetRecoilValueInfo_UNSTABLE,ef=M.useRecoilRefresher_UNSTABLE,tf=M.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,nf=M.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,of=M.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,rf=M.useRecoilCallback,af=M.useRecoilTransaction_UNSTABLE,sf=M.useGotoRecoilSnapshot,cf=M.useRecoilSnapshot,lf=M.useRecoilTransactionObserver_UNSTABLE,uf=M.snapshot_UNSTABLE,df=M.useRetain,ff=M.retentionZone;export{Id as a,Md as b,qd as c,Zd as d,Xd as e};
